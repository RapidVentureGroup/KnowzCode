{
  "name": "workgroup-spec-validator",
  "version": "1.0.0",
  "description": "Validates all specs in a WorkGroupID. Returns aggregated validation results for the entire Change Set.",
  "parameters": [
    {
      "name": "workgroup_id",
      "type": "string",
      "required": true,
      "description": "WorkGroupID to validate specs for"
    }
  ],
  "actions": [
    {
      "type": "python",
      "code": "from pathlib import Path\nimport re\nimport json\n\nworkgroup_id = inputs['workgroup_id']\n\n# Read tracker to find all NodeIDs in this WorkGroup\ntracker_path = Path('knowzcode/knowzcode_tracker.md')\nif not tracker_path.exists():\n    outputs['valid'] = False\n    outputs['error'] = 'knowzcode_tracker.md not found'\n    exit()\n\ntracker_text = tracker_path.read_text()\n\nnode_ids = []\nfor line in tracker_text.splitlines():\n    if workgroup_id in line and '`' in line:\n        match = re.search(r'`([A-Z_][A-Za-z0-9_]+)`', line)\n        if match:\n            node_id = match.group(1)\n            if node_id not in node_ids:  # Avoid duplicates\n                node_ids.append(node_id)\n\nif not node_ids:\n    outputs['valid'] = False\n    outputs['error'] = f'No NodeIDs found for WorkGroupID {workgroup_id} in tracker'\n    outputs['workgroup_id'] = workgroup_id\n    outputs['node_count'] = 0\n    exit()\n\nresults = []\ntotal_score = 0\nfailed_nodes = []\nall_errors = []\nall_warnings = []\n\nfor node_id in node_ids:\n    spec_path = Path(f'knowzcode/specs/{node_id}.md')\n    \n    if not spec_path.exists():\n        result = {\n            'node_id': node_id,\n            'valid': False,\n            'score': 0,\n            'errors': [f'Spec file does not exist at {spec_path}'],\n            'warnings': []\n        }\n        results.append(result)\n        failed_nodes.append(node_id)\n        all_errors.append(f'{node_id}: Spec file missing')\n        continue\n    \n    # Read and validate spec inline (mimics spec-validator logic)\n    content = spec_path.read_text()\n    errors = []\n    warnings = []\n    score = 100\n    \n    # Required sections check\n    required_sections = [\n        (r'##\\s*1\\.\\s*Purpose', '1. Purpose'),\n        (r'##\\s*2\\.\\s*Dependencies\\s*(&|and)\\s*Triggers', '2. Dependencies'),\n        (r'##\\s*3\\.\\s*Interfaces', '3. Interfaces'),\n        (r'##\\s*4\\.\\s*Core\\s*Logic', '4. Core Logic'),\n        (r'##\\s*6\\.\\s*Error\\s*Handling', '6. Error Handling'),\n        (r'##\\s*7\\.\\s*ARC\\s*Verification\\s*Criteria', '7. ARC Criteria')\n    ]\n    \n    for pattern, name in required_sections:\n        if not re.search(pattern, content, re.IGNORECASE):\n            errors.append(f'Missing {name} section')\n            score -= 15\n    \n    # Placeholder check\n    placeholder_patterns = [r'\\[Agent:', r'\\[TODO', r'\\[FILL', r'\\[TBD\\]', r'\\[INSERT']\n    for pattern in placeholder_patterns:\n        if re.search(pattern, content, re.IGNORECASE):\n            errors.append('Contains placeholder text')\n            score -= 20\n            break\n    \n    # ARC criteria check\n    arc_section = re.search(r'##\\s*7\\.\\s*ARC\\s*Verification\\s*Criteria(.+?)(?=##|$)', content, re.DOTALL | re.IGNORECASE)\n    if arc_section:\n        arc_content = arc_section.group(1)\n        criteria_count = len(re.findall(r'ARC_[A-Z]+_\\d+:', arc_content))\n        if criteria_count < 3:\n            errors.append(f'Only {criteria_count} testable ARC criteria (need 3+)')\n            score -= 15\n    else:\n        errors.append('ARC section empty or malformed')\n        score -= 20\n    \n    # Version/Date check\n    if not re.search(r'\\*\\*Version:\\*\\*', content):\n        warnings.append('Missing Version field')\n        score -= 5\n    if not re.search(r'\\*\\*Date:\\*\\*', content):\n        warnings.append('Missing Date field')\n        score -= 5\n    \n    # Length check\n    if len(content) < 500:\n        warnings.append('Spec appears incomplete (<500 chars)')\n        score -= 10\n    \n    score = max(0, score)\n    valid = (score >= 70 and len(errors) == 0)\n    \n    result = {\n        'node_id': node_id,\n        'valid': valid,\n        'score': score,\n        'errors': errors,\n        'warnings': warnings,\n        'spec_path': str(spec_path)\n    }\n    \n    results.append(result)\n    total_score += score\n    \n    if not valid:\n        failed_nodes.append(node_id)\n        for err in errors:\n            all_errors.append(f'{node_id}: {err}')\n    \n    for warn in warnings:\n        all_warnings.append(f'{node_id}: {warn}')\n\n# Calculate aggregate results\naverage_score = total_score / len(node_ids) if node_ids else 0\nall_valid = len(failed_nodes) == 0\n\noutputs['workgroup_id'] = workgroup_id\noutputs['node_count'] = len(node_ids)\noutputs['valid'] = all_valid\noutputs['failed_nodes'] = failed_nodes\noutputs['passed_nodes'] = [nid for nid in node_ids if nid not in failed_nodes]\noutputs['average_score'] = round(average_score, 1)\noutputs['results'] = results\noutputs['all_errors'] = all_errors\noutputs['all_warnings'] = all_warnings"
    }
  ]
}
